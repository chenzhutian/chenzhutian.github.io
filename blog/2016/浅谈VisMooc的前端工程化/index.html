<!DOCTYPE html><html class="theme-next gemini use-motion" lang="en"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="google-site-verification" content="yPKT5BEadvh5UAsnIX7Lni9S8yh2incOQmOuMulxVs4"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css"><meta name="keywords" content="hkust,vislab,求学在HKUST,"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2"><meta name="description" content="机缘巧合，年初的时候，老师叫我找师兄交接一下VisMooc的代码，我本以为今年Deadline要负责相关开发，因为项目比较脏乱，于是便赶在春节前把整个系统重写了一遍，后将过程记录整理成文，欢迎交流探讨。0.交待背景&emsp;&emsp;&emsp;VisMooc是组里的一个大项目，主要是给在线教育网站的各种数据提供可视化的分析工具，可以算是一个webapp。最初由丛磊师兄带头创立并实现完成，从0"><meta name="keywords" content="hkust,vislab,求学在HKUST"><meta property="og:type" content="article"><meta property="og:title" content="告别刀耕火种:浅谈VisMooc的前端工程化"><meta property="og:url" content="http://chenzhutian.org/blog/2016/浅谈VisMooc的前端工程化/index.html"><meta property="og:site_name" content="Zhutian Chen"><meta property="og:description" content="机缘巧合，年初的时候，老师叫我找师兄交接一下VisMooc的代码，我本以为今年Deadline要负责相关开发，因为项目比较脏乱，于是便赶在春节前把整个系统重写了一遍，后将过程记录整理成文，欢迎交流探讨。0.交待背景&emsp;&emsp;&emsp;VisMooc是组里的一个大项目，主要是给在线教育网站的各种数据提供可视化的分析工具，可以算是一个webapp。最初由丛磊师兄带头创立并实现完成，从0"><meta property="og:locale" content="en"><meta property="og:image" content="http://chenzhutian.org/blog/2016/浅谈VisMooc的前端工程化/mass-js-lib.png"><meta property="og:image" content="http://chenzhutian.org/blog/2016/浅谈VisMooc的前端工程化/libs.png"><meta property="og:image" content="http://chenzhutian.org/blog/2016/浅谈VisMooc的前端工程化/components1.png"><meta property="og:image" content="http://chenzhutian.org/blog/2016/浅谈VisMooc的前端工程化/components2.png"><meta property="og:image" content="http://chenzhutian.org/blog/2016/浅谈VisMooc的前端工程化/vuejs-component.png"><meta property="og:image" content="http://chenzhutian.org/blog/2016/浅谈VisMooc的前端工程化/vuejs-component2.png"><meta property="og:updated_time" content="2019-09-27T19:52:51.678Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="告别刀耕火种:浅谈VisMooc的前端工程化"><meta name="twitter:description" content="机缘巧合，年初的时候，老师叫我找师兄交接一下VisMooc的代码，我本以为今年Deadline要负责相关开发，因为项目比较脏乱，于是便赶在春节前把整个系统重写了一遍，后将过程记录整理成文，欢迎交流探讨。0.交待背景&emsp;&emsp;&emsp;VisMooc是组里的一个大项目，主要是给在线教育网站的各种数据提供可视化的分析工具，可以算是一个webapp。最初由丛磊师兄带头创立并实现完成，从0"><meta name="twitter:image" content="http://chenzhutian.org/blog/2016/浅谈VisMooc的前端工程化/mass-js-lib.png"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Gemini",version:"5.1.2",sidebar:{position:"left",display:"post",offset:12,offset_float:12,b2t:!1,scrollpercent:!1,onmobile:!1},fancybox:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn"}},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="http://chenzhutian.org/blog/2016/浅谈VisMooc的前端工程化/"><title>告别刀耕火种:浅谈VisMooc的前端工程化 | Zhutian Chen</title><script>!function(e,a,t,n,g,c,o){e.GoogleAnalyticsObject=g,e.ga=e.ga||function(){(e.ga.q=e.ga.q||[]).push(arguments)},e.ga.l=1*new Date,c=a.createElement(t),o=a.getElementsByTagName(t)[0],c.async=1,c.src="https://www.google-analytics.com/analytics.js",o.parentNode.insertBefore(c,o)}(window,document,"script",0,"ga"),ga("create","UA-106577121-1","auto"),ga("send","pageview")</script><script type="text/javascript">var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?636a52cc8951c69997f9af3f8e3bb81f";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script></head><body itemscope itemtype="http://schema.org/WebPage" lang="en"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">Zhutian Chen</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">博，三尺微命，一介书生</p></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>Home</a></li><li class="menu-item menu-item-blogs"><a href="/blogs" rel="section"><i class="menu-item-icon fa fa-fw fa-file-text"></i><br>blogs</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>Archives</a></li></ul></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://chenzhutian.org/blog/2016/浅谈VisMooc的前端工程化/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Zhutian Chen"><meta itemprop="description" content><meta itemprop="image" content="/images/avatar.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Zhutian Chen"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">告别刀耕火种:浅谈VisMooc的前端工程化</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-02-16T23:04:31+08:00">2016-02-16 </time></span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/中随笔/" itemprop="url" rel="index"><span itemprop="name">中随笔</span> </a></span></span><span class="post-meta-divider">|</span> <span class="page-pv"><i class="fa fa-file-o"></i> <span class="busuanzi-value" id="busuanzi_value_page_pv"></span></span></div></header><div class="post-body" itemprop="articleBody"><p>机缘巧合，年初的时候，老师叫我找师兄交接一下VisMooc的代码，我本以为今年Deadline要负责相关开发，因为项目比较脏乱，于是便赶在春节前把整个系统重写了一遍，后将过程记录整理成文，欢迎交流探讨。</p><h1 id="0-交待背景"><a href="#0-交待背景" class="headerlink" title="0.交待背景"></a>0.交待背景</h1><p> <br>  <a href="http://ihome.ust.hk/~qchenah/VisMooc/" target="_blank" rel="noopener">VisMooc</a>是组里的一个大项目，主要是给在线教育网站的各种数据提供可视化的分析工具，可以算是一个webapp。最初由<a href="http://conglei.org/" target="_blank" rel="noopener">丛磊</a>师兄带头创立并实现完成，从0.5版本发展到现在较为稳定的2.0版本，集合了屈老师以及很多师兄师姐的智慧和汗水，为组里赢得了无数的荣誉与名声，可以说是组里的王牌项目之一。<br>  由于特殊的生长环境，VisMooc的各种功能基本都是由不同的师兄在一个又一个的deadline中赶出来的，然后每年再对整个系统重构一遍，把各种功能整合上去。在这种特殊的“国情”下，VisMooc的代码野蛮生长，项目的性能必然是没有经过优化的，鲁棒性也不高，很多功能都是hack出来的。但是其实性能不好、鲁棒性不高也没关系，毕竟目前只是个演示用的Demo项目，并发访问量、日访问量都不怎么高，各种可视化的技术和概念能展示就行。<br>  但是VisMooc目前有一个无比巨大的坑，那就是代码毫无可维护性可言，灾难般的可维护性，许多部分相当混乱，开发目前的VisMooc，有种在茅房里吃佳肴的感觉，怎么都美味不起来。老实说，作为一个码农如果有一天你发现自己的开发效率奇低无比，你就要想想是不是自己的工作环境不够整洁，是不是自己的刀没有磨利。<br>  VisMooc的不可维护性集中体现在以下几点：<br><a id="more"></a></p><blockquote><ol><li>代码难以维护<ul><li>由于缺少统一的编码规范，并且不同的功能由不同的师兄开发，导致项目各部分的代码高度不统一,每个部分的代码都有不同的风格。</li><li>很多代码的变量名都是随便起的，比如<code>var a,b,kkk;</code>，基本不能做到变量名自解释，注释比较稀少，在通读代码之前变量含义和函数功能主要靠猜。</li><li>此外，模块化和组件化开发的特性较弱，目录结构和依赖关系较乱，一个组件的CSS文件可能在别的组件的目录下；有时候忽然在代码中看见了某个未曾谋面的对象，但是你却不知道它来自哪个组件。</li><li>历史负担较重，许多陈年老码，有些早已不用的，有些依然在用，混在一起。</li></ul></li><li>项目难以维护<ul><li>缺少项目管理工具，小作坊式编程。许多管理工具只是装上意思意思，但是并没有使用，比如Bitbucket的团队协作管理等。</li><li>有用npm和bower来管理第三方依赖包，但是<code>npm install</code>和<code>bower install</code>完了之后项目基本是运行不了的，经常是缺了某个依赖包，但是这个包不在dependence list里，要人肉去读码补全。</li><li>有用Git来做版本控制，但是.gitignore是随便写的，比如会把自己写的代码给ignore掉囧rz，所以在别的机子上clone项目的时候，往往会报错显示某个变量no reference，debug一通最后发现原来是缺了代码文件。<img src="/blog/2016/浅谈VisMooc的前端工程化/mass-js-lib.png" title="混乱的第三方js长达一脸"></li></ul></li><li>部署难以维护（<em>这一点其实略为要求过高</em>）<ul><li>没有版本号、内容指纹的概念，无法长期缓存以及精确控制缓存内容。</li><li>覆盖式发布，升级不够平滑。</li></ul></li></ol></blockquote><p>  这些问题的产生无比自然，早期的小作坊式的开发基本都有这类的问题，而这些问题基本都可以用工程化自动化的方法来解决。我就用VisMooc来作为一个案例，学习实践了一把如何以前端工程化的理念来重构整个系统。首先来整理一下需求：</p><blockquote><ul><li>开发<ol><li>组件化开发。整个webapp由各个组件构成，一个组件的Js、CSS和HTML维护在一起，尽量松耦合。</li><li>模块化开发。Js模块化，CSS模块化，HTML模块化，所有资源都是模块，并采取就近引入原则，哪里用哪里引，同时要做到防止资源重复引入。</li><li>文件实时监听、浏览器自动刷新。</li><li>依赖包管理，版本控制。</li><li>规范编码。编码规范的事可以参考<a href="http://book.douban.com/subject/21792530/" target="_blank" rel="noopener">《编写可维护的JavaScript》</a>，主要靠自觉。</li></ol></li><li>构建<ol><li>可以编译中间语言。比如支持Stylus、Less、Typescript等的编译。</li><li>支持Js、CSS的压缩和混肴。</li><li>允许图片压缩后以base64编码形式嵌入到CSS、Js或HTML中。</li><li>支持代码按需加载。将代码根据页面需求进行分割与合并，优化Http请求数。</li></ol></li><li>部署<ol><li>根据代码内容生成版本号，实现缓存控制，提示访问性能。</li><li>支持第三方类库的Js、CSS与自己所写的代码分离。</li></ol></li></ul></blockquote><p>  整理了一下，大约有11项的主要需求，对于目前这么一个展示性项目来说基本足够了。如何优雅的把他们都实现了呢？我们一步一步来。</p><h1 id="1-技术选型"><a href="#1-技术选型" class="headerlink" title="1.技术选型"></a>1.技术选型</h1><p> <br><img src="/blog/2016/浅谈VisMooc的前端工程化/libs.png" class="full-image nofancybox" alt="前端类库们" title="前端类库们"></p><p class="image-caption">前端类库们</p><p>  前端工程建设的第一项任务就是根据项目特征进行技术选型。VisMooc可以算是较为典型的Webapp，就目前的功能来看，还是一款只有一页的Single Page App。VisMooc的目标平台仅仅是PC，不支持在移动端使用(或许以后会支持在平板设备上使用)，其页面逻辑也较为简单，类似于一个Dashboard应用。</p><p><strong>前端渲染</strong><br>  在VisMooc2.0中，我们采用了Angular1来现实前端的模块化和各种功能。但是对于VisMooc来说，Angular略显臃肿，并且Angular1在性能上较为不足。随着前端圈子的发展，Angular的开发团队宣布在下一版本的Angular2将不兼容Angular1，这显然是个好机会让我选一个新的框架来重写一遍VisMooc，顺便也对VisMooc进行一下升级。<br>  前端框架日新月异，而VisMooc项目的前端框架有这么几个特殊需求：1.只针对PC平台；2.上手要简单，学习曲线平滑。有这两点，大热的React框架基本可以排除了。而Angular2目前生态圈还相当不完善（几乎没有生态圈），于是一个轻量级的<a href="http://vuejs.org/" target="_blank" rel="noopener">Vuejs</a>抓住了我的眼球。Vuejs是一个非常“小而美”的前端渲染框架。简洁、轻量并且强大，数据驱动，模块友好，支持组件化。学习曲线很平滑并且不高，社区友好，作者是个华人前谷歌工程师，已婚程序员，人相当的nice，可以看作者自己对于该框架的<a href="http://zhihu.com/question/38989845/answer/79216477?utm_campaign=webshare&utm_source=weibo&utm_medium=zhihu" target="_blank" rel="noopener">评价</a>。目前国内外已然有很多公司将Vus使用于实际生产环境中，国内知名的有阿里百度新浪小米等等。</p><p><strong>构建打包</strong><br>  为了更好的管理代码以及提升系统性能，我选用了最近很火的模块构建系统<a href="https://webpack.github.io/" target="_blank" rel="noopener">Webpack</a>来完成系统的构建任务。老实说目前的Webpack有点四不像，即是打包工具，又是构建工具，又是模块加载工具，却又不是一个完全的前端工程化工具，但是不管怎么说Webpack实在是相当强大。在Webpack的帮助下，我们可以做到node端与浏览器端共用代码，模块依赖管理，代码拆分，通过插件加载其它类型资源等等。Webpack 提供了强大的 loader 机制和 plugin 机制，loader 机制支持载入各种各样的静态资源，不只是 js 脚本，连 html、 css、 images 等各种资源都有相应的 loader 来做依赖管理和打包。而 plugin 则可以对整个 webpack 的流程进行一定的控制。比如在安装并配置了 css-loader 和 less-loader 之后，就可以通过 <code>require('./bootstrap.less')</code> 这样的方式在任意需要的地方给网页载入一份用less编写的样式表,Webpack会自动在构建时生成css文件并按需加载，非常方便。</p><p><strong>依赖包管理</strong><br>  市面上有许许多多种包管理工具，常见的有npm和bower。一般来说，人们习惯用npm来管理nodejs相关的包，用bower来管理前端所依赖的类库。随着前端生态圈的高速发展，Browserify、Webpack 等支持 CommonJS 规范的构建工具的流行, npm在过去的一年里基本干掉了了bower、component、spm等一众前端包管理工具，大有一统前后的趋势。这对于我这种喜欢”大一统”的人来说简直不能再好，隧毫不犹豫的用npm来管理第三方包的依赖。<br>  利用npm来做第三方包管理工具无比简单，它会自动的在你的项目目录下创建一个叫<em>package.json</em>的文件，里面记录了项目相关的信息，以及该项目所依赖的各种类库。当你需要用到某个发布在npm上的第三方类库,假设叫<em>super-lib</em>，你只需要在项目文件夹下用命令行输入<code>npm install super-lib --save-dev</code>即可完成自动下载这个类库、自动将依赖关系写进<em>package.json</em>中的<code>dependencies</code>下。配合Webpack，可以用<code>require</code>等语句在任何需要的地方引入第三方类库。<br></p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//package.json file, which documents the dependent libs.</span></span><br><span class="line">{</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"example"</span>,</span><br><span class="line">  <span class="string">"version"</span>: <span class="string">"0.0.1"</span>,</span><br><span class="line">  <span class="string">"private"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">"dependencies"</span>: {</span><br><span class="line">    <span class="string">"super-lib"</span>: <span class="string">"^0.4.5"</span>,</span><br><span class="line">    <span class="string">"beautiful-lib"</span>: <span class="string">"^0.22.0"</span>,</span><br><span class="line">    <span class="string">"smart-css"</span>: <span class="string">"^0.7.0"</span></span><br><span class="line">    <span class="string">"vuejs"</span>: <span class="string">"^3.4.0"</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><p>  通过npm下载的第三方类库都不必push到git服务器上，别的开发者要重新下载项目所依赖的第三方类库只需在项目目录下执行<code>npm install</code>命令即可自动将项目所依赖的类库给补齐全。<br>  关于npm和bower的更多讨论可以参考<a href="https://www.zhihu.com/question/24414899" target="_blank" rel="noopener">这里(知乎)</a>，或者<a href="https://github.com/bower/bower/issues/1520" target="_blank" rel="noopener">这里(github)</a>。</p><h1 id="2-项目目录的设计"><a href="#2-项目目录的设计" class="headerlink" title="2. 项目目录的设计"></a>2. 项目目录的设计</h1><p> <br>  传统的前端项目按照文件类型来组织目录结构，所以常见的目录结构是这样的：<br></p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Project</span><br><span class="line">    |-src</span><br><span class="line">        |-HTML</span><br><span class="line">        |-CSS</span><br><span class="line">        |-JS</span><br><span class="line">        |-Images</span><br></pre></td></tr></tbody></table></figure><p></p><p>  这样做的好处就是简单粗暴，非常直接，只要有一点点的编程经验的人也可以一眼看懂项目的组织方式。但是这样做的坏处也是很明显的，就是项目维护成本较高，并且为项目臃肿埋下了工程隐患：</p><blockquote><ul><li>如果项目中的一个功能有了问题，维护的时候要在js目录下找到对应的逻辑修改，再到css目录下找到对应的样式文件修改一下，如果图片不对，还要再跑到images目录下找对应的开发资源。</li><li>CSS下的文件不知道哪些图片在用，哪些已经废弃了，谁也不敢删除，文件越来越多。Js/HTML亦然。</li><li>多人合作时，很可能多个人改同一份代码文件，造成冲突。</li></ul></blockquote><p>除非项目代码量很少、并且只有1人负责开发，这种基于文件类型的项目结构都是应该被抛弃的。鉴于我们希望采取组件化开发，整个app由组件构成，因此我们可以根据代码成分来划分项目目录，比如:<br></p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Project</span><br><span class="line">    |-src</span><br><span class="line">        |-Components    <span class="comment">// 存放组件资源</span></span><br><span class="line">        |-Static        <span class="comment">// 存放非组件资源</span></span><br></pre></td></tr></tbody></table></figure><p></p><p>由于我们采用npm来管理所依赖的第三方类库，其默认的文件夹名为<code>node_modules</code>，但是并非所有依赖的第三方类库都托管在npm上，有一些神秘的第三方资源我们需要自己管理。我们可以把它们放到<code>src</code>目录下，然后push到git服务器中来避免丢失文件。这样，我们的目录结构就变成：<br></p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Project</span><br><span class="line">    |-node_modules      <span class="comment">// npm上的第三方资源</span></span><br><span class="line">    |-src</span><br><span class="line">        |-Components    <span class="comment">// 存放组件资源</span></span><br><span class="line">        |-Static        <span class="comment">// 存放非组件资源</span></span><br><span class="line">        |-lib           <span class="comment">// 存放不在npm上的第三方资源</span></span><br></pre></td></tr></tbody></table></figure><p></p><p>最后，由于我们采用Vuejs来开发前端,其中有一些其特有的代码组成部分，比如<code>component</code>、<code>filter</code>、<code>directive</code>等。<code>component</code>放进<code>Components</code>目录十分自然，但是别的部分算不上真正的组件，放在Static里又觉得分外别扭。为了使开发目录更清晰，我给他们单独放在对应的目录中，最终我们的开发目录就变成：<br></p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Project</span><br><span class="line">    |-node_modules      <span class="comment">// npm上的第三方资源</span></span><br><span class="line">    |-src</span><br><span class="line">        |-Components    <span class="comment">// 存放自己实现的组件</span></span><br><span class="line">        |-Filters       <span class="comment">// 存放自己实现的filter</span></span><br><span class="line">        |-Directives    <span class="comment">// 存放自己实现的directives</span></span><br><span class="line">        |-Static        <span class="comment">// 存放非组件资源</span></span><br><span class="line">        |-lib           <span class="comment">// 存放不在npm上的第三方资源</span></span><br></pre></td></tr></tbody></table></figure><p></p><h1 id="3-愉快的写码"><a href="#3-愉快的写码" class="headerlink" title="3. 愉快的写码"></a>3. 愉快的写码</h1><p> <br>  在做完种种的准备工作之后，我们终于要开始写代码了。需求中的第一条就是<strong>组件化开发</strong>，首先简单介绍一下什么是组件化开发。</p><img src="/blog/2016/浅谈VisMooc的前端工程化/components1.png"><p>  组件化开发的基本理念如上图所示，引用一下<a href="https://www.zhihu.com/people/fouber" target="_blank" rel="noopener">张云龙</a>大神的文字和图，所谓组件化开发可以理解成：</p><blockquote><ul><li>页面上的每个 独立的 可视/可交互区域视为一个组件;</li><li>每个组件对应一个工程目录，组件所需的各种资源都在这个目录下就近维护;</li><li>每个组件相对独立，页面只不过是组件的容器，组件自由组合形成功能完整的界面;</li><li>当不需要某个组件，或者想要替换组件时，可以整个目录删除/替换。</li></ul></blockquote><p>  组件化开发的核心优势在于其分治策略。从工程层面来看，它将开发任务划分至合适的粒度，便于给不同的开发者分配任务；从开发的角度来看，由于每个组件的相对独立性，开发者在开发期间不会产生依赖冲突，只需专注于自身的模块开发，提高开发效率；从维护的角度来看，于模块相关的资源均组织在一起，十分便于维护和整理。<br>  可以想象，在模块化的支持下，一个项目的开发可能是这样组织的(图引自<a href="https://github.com/fouber/blog/issues/10" target="_blank" rel="noopener">云龙</a>大神)：<br><img src="/blog/2016/浅谈VisMooc的前端工程化/components2.png"></p><p>  令人愉快的是，Vuejs的作者提供了一个插件vue-loader，可以将Vuejs的代码整合进Webpage的构建系统中，从而漂亮的实现了组件化开发的需求。通过使用Vuejs+Webpack这样的组合，我们可以把每一个组件的样式、模板和脚本集合成一个文件里。 一个组件就是一个文件，麻雀虽小五脏俱全，里面包含了组件之间的依赖关系，整个组件从外观到结构到特性再到依赖关系都一览无余。</p><img src="/blog/2016/浅谈VisMooc的前端工程化/vuejs-component.png" title="Vue组件文件"><p>  如上图所示，在一个example.vue文件里，包含了该example组件的Template(HTML)/JS/CSS。当然如果每个部分很长，也可以将内容分别写至对应的HTML/JS/CSS文件下，再引用到vue文件里。<br>  同时，我们的第二个需求<strong>模块化开发</strong>也在此一并实现了。在Webpack的帮助下，该组件所依赖的所有第三方资源都可以当作模块，直接就近引用（图中采用了ES6语法）—— 需要bootstrap的css，import进来，需要d3的js，也import进来，这个组件要什么，就在这里import就好，至于重复引入的问题Webpack会帮你解决。<br>  有了组件化和模块化开发，像往常的<em>“之前用过但是现在不用的第三方类库由于不知道别人还要不要用所以不敢删除只能留着”</em>这样的问题就能彻底解决了，还有像上文图中出现的<em>“引用的js类库长达一脸”</em>的情况也能大为改善。<br>  此外，如上图所示，我们还引入了一个less文件，只要我们在Webpack里开启了less-loader，任何less代码在最终输出的时候，会自动被Webpack预编译成CSS代码并插入到合适的地方。在Vue文件中，只要你开启了Webpack的各种loader，各种预编译方言都不是问题（比如sass、jade、typescript等）：</p><img src="/blog/2016/浅谈VisMooc的前端工程化/vuejs-component2.png" title="Vue组件文件"><p>  这样，支持中间语言的编译的需求也搞定了。<br>  这样再大的系统、再复杂的界面，也可以用这样的方式庖丁解牛，分成一件一件的模块来写。并且就像你能看到的，<strong>相当易于维护和适合多人共同开发</strong>。</p><h1 id="4-潇洒的构建与部署"><a href="#4-潇洒的构建与部署" class="headerlink" title="4. 潇洒的构建与部署"></a>4. 潇洒的构建与部署</h1><blockquote><ul><li>开发<ol><li><del>组件化开发。整个webapp由各个组件构成，一个组件的Js、CSS和HTML维护在一起，尽量松耦合。</del></li><li><del>模块化开发。Js模块化，CSS模块化，HTML模块化，所有资源都是模块，并采取就近引入原则，哪里用哪里引，同时要做到防止资源重复引入。</del></li><li>文件实时监听、浏览器自动刷新。</li><li><del>依赖包管理，版本控制。</del></li><li><del>规范编码。编码规范的事可以参考<a href="http://book.douban.com/subject/21792530/" target="_blank" rel="noopener">《编写可维护的JavaScript》</a>，主要靠自觉。</del></li></ol></li><li>构建<ol><li><del>可以编译中间语言。比如支持Stylus、Less、Typescript等的编译。</del></li><li>支持Js、CSS的压缩和混肴。</li><li>允许图片压缩后以base64编码形式嵌入到CSS、Js或HTML中。</li><li>支持代码按需加载。将代码根据页面需求进行分割与合并，优化Http请求数。</li></ol></li><li>部署<ol><li>根据代码内容生成版本号，实现缓存控制，提示访问性能。</li><li>支持第三方类库的Js、CSS与自己所写的代码分离。</li></ol></li></ul></blockquote><p>  到这里，剩下的任务主要都是构建和部署部分了，这些都将依靠Webpack来实现，而我们所需要做的，仅仅是配置Webpack的配置文件即可搞定一切。Webpack的配置文件是一个js文件<code>webpack.config.js</code>，但是内容就像<code>package.json</code>一样，基本就是一个<code>javascript</code>对象，所需要的一切都在里面。<br>  一些常规任务，比如支持文件实时监听、浏览器自动刷新，可以通过安装Webpack的官方配套的调试用服务器<code>webpack-dev-server</code>解决,而支持 JS/CSS/图片压缩混肴等任务可谓老生常谈，只需直接开启Webpack自带的优化插件即可解决:<br></p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">    <span class="comment">//webpack.config.js</span></span><br><span class="line">    ...</span><br><span class="line">    plugins:{</span><br><span class="line">        <span class="keyword">new</span> webpack.optimize.UglifyJsPlugin(),</span><br><span class="line">        <span class="keyword">new</span> webpack.optimize.OccurenceOrderPlugin(),</span><br><span class="line">        <span class="keyword">new</span> webpack.optimize.DedupePlugin()</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><p>  现代浏览器一般都默认开启本地缓存功能，当第二次打开同一个网站的时候，会根据网站内请求的链接来决定是否读取缓存，比如上回打开网页请求了一个<code>"/plugin.js"</code>,下一次打开依然请求<code>/plugin.js</code>的话，浏览器会优先查找本地是缓存，从而提高了网页的加载速度。如果文件的内容发生了改变而文件名没有变化的话，便会导致读取缓存，加载过时的代码文件，造成网页显示错误。解决这个问题的方法有很多，其中一个相当不错的方法就是根据文件内容给文件名打上hash指纹。这样每当文件内容发送变化，文件名就会发生对应的改变。这里有一篇超赞的文章讲这个问题<a href="https://www.zhihu.com/question/20790576/answer/32602154" target="_blank" rel="noopener">《大公司里怎样开发和部署前端代码？》</a>，作者还是云龙大神。<br>  在Webpack里实现打hash指纹简单飞起，只需在Output选项里进行如下配置即可：<br></p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">    <span class="comment">//webpack.config.js</span></span><br><span class="line">    ...</span><br><span class="line">    output: {</span><br><span class="line">        ...</span><br><span class="line">        filename: <span class="string">'./js/[name].[hash].js'</span></span><br><span class="line">    },</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><p>  上面配置的意思就是输出一个文件，它的名字叫<code>[name].[hash].js</code>,其中<code>[name]</code>是文件的本命，Webpack会给你自动替换上，<code>[hash]</code>是文件的hash指纹，Webpack也会给你自动给计算出来替换上。<br>  Webpack那么强大，它有没有什么令人无语的地方呢？有一点可能算是不太好的地方，那就是Webpack默认会把引入的第三方代码和你自己写的代码一起打包成一个文件，这显然是不太好的：首先第三方库的代码往往并不会经常修改，用户缓存了一次之后很长一段时间内都不会再需要下载新的版本；其次第三方库的代码很可能会利用CDN渠道分发，你上别的网站缓存的第三方库，在下一个网站可能还能用，大大提高了整体浏览速度，而跟自己的代码打包在一起，就放弃了CDN的优势。<br>  想要将第三方类库的代码跟自己的代码分离依然很简单，也是配置一行就搞定，比如你想把引入的<code>Bootstrap</code>、<code>d3js</code>资源抽出来，可以进行如下配置:<br></p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">    <span class="comment">//webpack.config.js</span></span><br><span class="line">    ...</span><br><span class="line">    entry:{</span><br><span class="line">        app:<span class="string">'index.js'</span>,</span><br><span class="line">        vendors:[<span class="string">'bootstrap'</span>,<span class="string">'d3js'</span>]</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><p>  上面的意思就是说，最终生成的文件的代码入口点有两个，其中一个是自己的代码入口点<code>app.js</code>,由自己的代码<code>index.js</code>及其中引用的资源文件组成，另一个代码入口点是<code>vendors.js</code>，里面包括出现在<code>vendors</code>列表里的第三方引用的模块代码。<br>  这样做还有一个问题，就是在<code>vendors.js</code>里的代码在<code>app.js</code>里也会有一份，这样就代码重复了。为了解决这个问题，要用到Webpack官方的一个叫<code>CommonsChunk</code>的插件，可以进行如下配置:<br></p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">    <span class="comment">//webpack.config.js</span></span><br><span class="line">    ...</span><br><span class="line">    plugins:[</span><br><span class="line">        <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(<span class="string">'vendors'</span>, <span class="string">'./js/vendors.[hash].js'</span>)</span><br><span class="line">    ]</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><p>  上面这样设置之后，Webpack会检测各个入口文件生成的代码，如果里面引用的代码有出现在<code>vendors</code>列表里的话，会被自动抽出来放到<code>./js/vendors.[hash].js</code>里。（感谢评论中 @寒霭 的提醒）<br>  这样一来，所有你想单独抽出来的代码或者资源模块，你只需把他们添加进<code>vendors</code>数组就好了。由于支持模块化开发，如果是通过<code>npm</code>下载的模块资源，直接把模块的名字填进<code>vendors</code>数组即可，Webpack会自动解析。<br>  此时此刻，我们还剩最后一个需求就搞定了，即支持代码按需加载，根据页面将代码进行分割与合并。这个也是Webpack的主打卖点之一，涉及<code>CommonsChunk</code>更深入的内容，可以讲上好久。可惜的是我们的VisMooc中目前只有一个页面，是彻彻底底的单页应用，并不需要分割代码，暂时还用不上。目前因为缺乏实操经验，我对这个功能的理解也并不深，以后如果有机会用到，再讲讲好了。</p><h1 id="5-总结-amp-后记"><a href="#5-总结-amp-后记" class="headerlink" title="5. 总结&后记"></a>5. 总结&后记</h1><blockquote><ul><li>开发<ol><li><del>组件化开发。整个webapp由各个组件构成，一个组件的Js、CSS和HTML维护在一起，尽量松耦合。</del></li><li><del>模块化开发。Js模块化，CSS模块化，HTML模块化，所有资源都是模块，并采取就近引入原则，哪里用哪里引，同时要做到防止资源重复引入。</del></li><li><del>文件实时监听、浏览器自动刷新。</del></li><li><del>依赖包管理，版本控制。</del></li><li><del>规范编码。编码规范的事可以参考<a href="http://book.douban.com/subject/21792530/" target="_blank" rel="noopener">《编写可维护的JavaScript》</a>，主要靠自觉。</del></li></ol></li><li>构建<ol><li><del>可以编译中间语言。比如支持Stylus、Less、Typescript等的编译。</del></li><li><del>支持Js、CSS的压缩和混肴。</del></li><li><del>允许图片压缩后以base64编码形式嵌入到CSS、Js或HTML中。</del></li><li><del>支持代码按需加载。将代码根据页面需求进行分割与合并，优化Http请求数。</del></li></ol></li><li>部署<ol><li><del>根据代码内容生成版本号，实现缓存控制，提示访问性能。</del></li><li><del>支持第三方类库的Js、CSS与自己所写的代码分离。</del></li></ol></li></ul></blockquote><p>  到这里，所有的需求算是都已经实现了。经过这轮重写，整个项目变得无比清爽，开发起来顺畅自然，Linus有句名言叫<em>“Talk is cheap,show me the code”</em>，对比重写之前有多好，谁上谁知道。<br>  这次重写，充分感受到了技术选型的重要性。吃螃蟹就要蟹八件，吃核桃就该上核桃夹，技术栈选的好，解决问题削铁如泥，做起来又快又好。<br>  写工程代码，性能效率、拓展性、维护性等等都需要考虑到。鉴于做科研往往只需要一个能show的demo就行，所以要求也不能太高。但是如果平时养成了好习惯，不管是写再小的代码，写出来都会是很漂亮很优雅；假如平时养成了坏习惯，写再大的项目，投入再多的时间，都会写得不堪入目，最后产出不能。这其实也是个态度问题。<br>  前端工程化还有很长的路要走，云龙大神在这方面的贡献十分巨大，毕竟是国内前端工程第一人。希望前端圈子能越来越热，越来越好吧。</p></div><footer class="post-footer"><div class="post-tags"><a href="/tags/hkust/" rel="tag"># hkust</a> <a href="/tags/vislab/" rel="tag"># vislab</a> <a href="/tags/求学在HKUST/" rel="tag"># 求学在HKUST</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/blog/2016/博半我在想什么/" rel="next" title="博半我在想什么"><i class="fa fa-chevron-left"></i> 博半我在想什么</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/blog/2016/要你命三千——TVCG二十年版/" rel="prev" title="要你命三千——TVCG二十年版">要你命三千——TVCG二十年版 <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article><div class="post-spread"><div class="bdsharebuttonbox"><a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a> <a href="#" class="bds_douban" data-cmd="douban" title="分享到豆瓣网"></a> <a href="#" class="bds_sqq" data-cmd="sqq" title="分享到QQ好友"></a> <a href="#" class="bds_qzone" data-cmd="qzone" title="分享到QQ空间"></a> <a href="#" class="bds_weixin" data-cmd="weixin" title="分享到微信"></a> <a href="#" class="bds_tieba" data-cmd="tieba" title="分享到百度贴吧"></a> <a href="#" class="bds_twi" data-cmd="twi" title="分享到Twitter"></a> <a href="#" class="bds_fbook" data-cmd="fbook" title="分享到Facebook"></a> <a href="#" class="bds_more" data-cmd="more"></a> <a class="bds_count" data-cmd="count"></a></div><script>window._bd_share_config={common:{bdText:"",bdMini:"2",bdMiniList:!1,bdPic:""},share:{bdSize:"16",bdStyle:"0"},image:{viewList:["tsina","douban","sqq","qzone","weixin","twi","fbook"],viewText:"分享到：",viewSize:"16"}}</script><script>with(document)(getElementsByTagName("head")[0]||body).appendChild(createElement("script")).src="//bdimg.share.baidu.com/static/api/js/share.js?cdnversion="+~(-new Date/36e5)</script></div></div></div><div class="comments" id="comments"></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">Table of Contents</li><li class="sidebar-nav-overview" data-target="site-overview">Overview</li></ul><section class="site-overview sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="Zhutian Chen"><p class="site-author-name" itemprop="name">Zhutian Chen</p><p class="site-description motion-element" itemprop="description">Zhutian Chen, a Ph.D. student at HKUST, interested in Visulization</p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">19</span> <span class="site-state-item-name">posts</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/index.html"><span class="site-state-item-count">2</span> <span class="site-state-item-name">categories</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/index.html"><span class="site-state-item-count">21</span> <span class="site-state-item-name">tags</span></a></div></nav><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/chenzhutian" target="_blank" title="github"><i class="fa fa-fw fa-globe"></i>github</a> </span><span class="links-of-author-item"><a href="https://www.zhihu.com/people/unhealthy" target="_blank" title="zhihu"><i class="fa fa-fw fa-globe"></i>zhihu</a></span></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#0-交待背景"><span class="nav-number">1.</span> <span class="nav-text">0.交待背景</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1-技术选型"><span class="nav-number">2.</span> <span class="nav-text">1.技术选型</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-项目目录的设计"><span class="nav-number">3.</span> <span class="nav-text">2. 项目目录的设计</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-愉快的写码"><span class="nav-number">4.</span> <span class="nav-text">3. 愉快的写码</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-潇洒的构建与部署"><span class="nav-number">5.</span> <span class="nav-text">4. 潇洒的构建与部署</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-总结-amp-后记"><span class="nav-number">6.</span> <span class="nav-text">5. 总结&后记</span></a></li></ol></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">© 2014 — <span itemprop="copyrightYear">2020</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Zhutian Chen</span></div><div class="busuanzi-count"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="site-uv"><i class="fa fa-user"></i> <span class="busuanzi-value" id="busuanzi_value_site_uv"></span> </span><span class="site-pv"><i class="fa fa-eye"></i> <span class="busuanzi-value" id="busuanzi_value_site_pv"></span></span></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/js/bundle.js"></script></body></html>